{"ast":null,"code":"import { useState, memo, useMemo, useEffect, Component } from 'react';\nimport { observe, unobserve, isObservable, raw, observable } from '@nx-js/observer-util';\nimport { unstable_batchedUpdates } from './react-platform'; // it is window in the DOM and global in NodeJS and React Native\n\nconst isDOM = typeof window !== 'undefined';\nconst isNative = typeof global !== 'undefined';\nconst globalObj = isDOM ? window : isNative ? global : undefined;\nconst hasHooks = typeof useState === 'function';\nlet isInsideFunctionComponent = false;\nconst COMPONENT = Symbol('owner component');\n\nfunction view(Comp) {\n  const isStatelessComp = !(Comp.prototype && Comp.prototype.isReactComponent);\n  let ReactiveComp;\n\n  if (isStatelessComp && hasHooks) {\n    // use a hook based reactive wrapper when we can\n    ReactiveComp = memo(props => {\n      // use a dummy setState to update the component\n      const [, setState] = useState(); // create a memoized reactive wrapper of the original component (render)\n      // at the very first run of the component function\n\n      const render = useMemo(() => observe(Comp, {\n        scheduler: () => setState({}),\n        lazy: true\n      }), // Adding the original Comp here is necessary to make React Hot Reload work\n      // it does not affect behavior otherwise\n      [Comp]); // cleanup the reactive connections after the very last render of the component\n\n      useEffect(() => {\n        return () => unobserve(render);\n      }, []); // the isInsideFunctionComponent flag is used to toggle `store` behavior\n      // based on where it was called from\n\n      isInsideFunctionComponent = true;\n\n      try {\n        // run the reactive render instead of the original one\n        return render(props);\n      } finally {\n        isInsideFunctionComponent = false;\n      }\n    });\n  } else {\n    const BaseComp = isStatelessComp ? Component : Comp; // a HOC which overwrites render, shouldComponentUpdate and componentWillUnmount\n    // it decides when to run the new reactive methods and when to proxy to the original methods\n\n    class ReactiveClassComp extends BaseComp {\n      constructor(props, context) {\n        super(props, context);\n        this.state = this.state || {};\n        this.state[COMPONENT] = this; // create a reactive render for the component\n\n        this.render = observe(this.render, {\n          scheduler: () => this.setState({}),\n          lazy: true\n        });\n      }\n\n      render() {\n        return isStatelessComp ? Comp(this.props, this.context) : super.render();\n      } // react should trigger updates on prop changes, while easyState handles store changes\n\n\n      shouldComponentUpdate(nextProps, nextState) {\n        const {\n          props,\n          state\n        } = this; // respect the case when the user defines a shouldComponentUpdate\n\n        if (super.shouldComponentUpdate) {\n          return super.shouldComponentUpdate(nextProps, nextState);\n        } // return true if it is a reactive render or state changes\n\n\n        if (state !== nextState) {\n          return true;\n        } // the component should update if any of its props shallowly changed value\n\n\n        const keys = Object.keys(props);\n        const nextKeys = Object.keys(nextProps);\n        return nextKeys.length !== keys.length || nextKeys.some(key => props[key] !== nextProps[key]);\n      } // add a custom deriveStoresFromProps lifecyle method\n\n\n      static getDerivedStateFromProps(props, state) {\n        if (super.deriveStoresFromProps) {\n          // inject all local stores and let the user mutate them directly\n          const stores = mapStateToStores(state);\n          super.deriveStoresFromProps(props, ...stores);\n        } // respect user defined getDerivedStateFromProps\n\n\n        if (super.getDerivedStateFromProps) {\n          return super.getDerivedStateFromProps(props, state);\n        }\n\n        return null;\n      }\n\n      componentWillUnmount() {\n        // call user defined componentWillUnmount\n        if (super.componentWillUnmount) {\n          super.componentWillUnmount();\n        } // clean up memory used by Easy State\n\n\n        unobserve(this.render);\n      }\n\n    }\n\n    ReactiveComp = ReactiveClassComp;\n  }\n\n  ReactiveComp.displayName = Comp.displayName || Comp.name; // static props are inherited by class components,\n  // but have to be copied for function components\n\n  if (isStatelessComp) {\n    for (let key of Object.keys(Comp)) {\n      ReactiveComp[key] = Comp[key];\n    }\n  }\n\n  return ReactiveComp;\n}\n\nfunction mapStateToStores(state) {\n  // find store properties and map them to their none observable raw value\n  // to do not trigger none static this.setState calls\n  // from the static getDerivedStateFromProps lifecycle method\n  const component = state[COMPONENT];\n  return Object.keys(component).map(key => component[key]).filter(isObservable).map(raw);\n}\n\nfunction store(obj) {\n  // do not create new versions of the store on every render\n  // if it is a local store in a function component\n  // create a memoized store at the first call instead\n  if (hasHooks && isInsideFunctionComponent) {\n    return useMemo(() => observable(obj), []);\n  }\n\n  return observable(obj);\n}\n/* eslint camelcase: 0 */\n// until the function is finished running\n\n\nfunction batch(fn, ctx, args) {\n  let result;\n  unstable_batchedUpdates(() => result = fn.apply(ctx, args));\n  return result;\n} // this creates and returns a batched version of the passed function\n// the cache is necessary to always map the same thing to the same function\n// which makes sure that addEventListener/removeEventListener pairs don't break\n\n\nconst cache = new WeakMap();\n\nfunction batchFn(fn) {\n  if (typeof fn !== 'function') {\n    return fn;\n  }\n\n  let batched = cache.get(fn);\n\n  if (!batched) {\n    batched = function (...args) {\n      return batch(fn, this, args);\n    };\n\n    cache.set(fn, batched);\n  }\n\n  return batched;\n} // batched obj.addEventListener(cb) like callbacks\n\n\nfunction batchMethodsCallbacks(obj, methods) {\n  methods.forEach(method => batchMethodCallbacks(obj, method));\n}\n\nfunction batchMethodCallbacks(obj, method) {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, method);\n\n  if (descriptor && descriptor.writable && typeof descriptor.value === 'function') {\n    obj[method] = new Proxy(descriptor.value, {\n      apply(target, ctx, args) {\n        return Reflect.apply(target, ctx, args.map(batchFn));\n      }\n\n    });\n  }\n} // batches obj.onevent = fn like calls\n\n\nfunction batchMethods(obj, methods) {\n  methods.forEach(method => batchMethod(obj, method));\n}\n\nfunction batchMethod(obj, method) {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, method);\n\n  if (descriptor && descriptor.configurable) {\n    const newDescriptor = Object.assign({}, descriptor, {\n      set(value) {\n        return descriptor.set.call(this, batchFn(value));\n      }\n\n    });\n    Object.defineProperty(obj, method, newDescriptor);\n  }\n} // do a sync batching for the most common task sources\n// this should be removed when React's own batching is improved in the future\n// batch timer functions\n\n\nbatchMethodsCallbacks(globalObj, ['setTimeout', 'setInterval', 'requestAnimationFrame', 'requestIdleCallback']);\n\nif (globalObj.Promise) {\n  batchMethodsCallbacks(Promise.prototype, ['then', 'catch']);\n} // batch addEventListener calls\n\n\nif (globalObj.EventTarget) {\n  batchMethodsCallbacks(EventTarget.prototype, ['addEventListener', 'removeEventListener']);\n} // this batches websocket event handlers\n\n\nif (globalObj.WebSocket) {\n  batchMethods(WebSocket.prototype, ['onopen', 'onmessage', 'onerror', 'onclose']);\n} // HTTP event handlers are usually wrapped by Promises, which is covered above\n\n\nexport { batch, store, view };","map":{"version":3,"sources":["../src/utils.js","../src/view.js","../src/store.js","../src/scheduler.js"],"names":["isDOM","isNative","globalObj","hasHooks","isInsideFunctionComponent","COMPONENT","Symbol","isStatelessComp","Comp","ReactiveComp","memo","props","useState","render","useMemo","observe","scheduler","setState","lazy","useEffect","unobserve","BaseComp","constructor","shouldComponentUpdate","state","keys","Object","nextKeys","key","nextProps","stores","mapStateToStores","componentWillUnmount","component","observable","unstable_batchedUpdates","result","fn","cache","batched","batch","methods","method","batchMethodCallbacks","descriptor","obj","apply","Reflect","args","batchMethod","newDescriptor","set","batchFn","batchMethodsCallbacks","Promise","EventTarget","batchMethods","WebSocket"],"mappings":"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","sourcesContent":["import { useState } from 'react'\n\n// try to find the global object\n// it is window in the DOM and global in NodeJS and React Native\nconst isDOM = typeof window !== 'undefined'\nconst isNative = typeof global !== 'undefined'\nexport const globalObj = isDOM ? window : isNative ? global : undefined\n\nexport const hasHooks = typeof useState === 'function'\n","import { Component, useState, useEffect, useMemo, memo } from 'react'\nimport { observe, unobserve, raw, isObservable } from '@nx-js/observer-util'\nimport { hasHooks } from './utils'\n\nexport let isInsideFunctionComponent = false\nconst COMPONENT = Symbol('owner component')\n\nexport default function view (Comp) {\n  const isStatelessComp = !(Comp.prototype && Comp.prototype.isReactComponent)\n\n  let ReactiveComp\n\n  if (isStatelessComp && hasHooks) {\n    // use a hook based reactive wrapper when we can\n    ReactiveComp = memo(props => {\n      // use a dummy setState to update the component\n      const [, setState] = useState()\n\n      // create a memoized reactive wrapper of the original component (render)\n      // at the very first run of the component function\n      const render = useMemo(\n        () =>\n          observe(Comp, {\n            scheduler: () => setState({}),\n            lazy: true\n          }),\n        // Adding the original Comp here is necessary to make React Hot Reload work\n        // it does not affect behavior otherwise\n        [Comp]\n      )\n\n      // cleanup the reactive connections after the very last render of the component\n      useEffect(() => {\n        return () => unobserve(render)\n      }, [])\n\n      // the isInsideFunctionComponent flag is used to toggle `store` behavior\n      // based on where it was called from\n      isInsideFunctionComponent = true\n      try {\n        // run the reactive render instead of the original one\n        return render(props)\n      } finally {\n        isInsideFunctionComponent = false\n      }\n    })\n  } else {\n    const BaseComp = isStatelessComp ? Component : Comp\n    // a HOC which overwrites render, shouldComponentUpdate and componentWillUnmount\n    // it decides when to run the new reactive methods and when to proxy to the original methods\n    class ReactiveClassComp extends BaseComp {\n      constructor (props, context) {\n        super(props, context)\n\n        this.state = this.state || {}\n        this.state[COMPONENT] = this\n\n        // create a reactive render for the component\n        this.render = observe(this.render, {\n          scheduler: () => this.setState({}),\n          lazy: true\n        })\n      }\n\n      render () {\n        return isStatelessComp\n          ? Comp(this.props, this.context)\n          : super.render()\n      }\n\n      // react should trigger updates on prop changes, while easyState handles store changes\n      shouldComponentUpdate (nextProps, nextState) {\n        const { props, state } = this\n\n        // respect the case when the user defines a shouldComponentUpdate\n        if (super.shouldComponentUpdate) {\n          return super.shouldComponentUpdate(nextProps, nextState)\n        }\n\n        // return true if it is a reactive render or state changes\n        if (state !== nextState) {\n          return true\n        }\n\n        // the component should update if any of its props shallowly changed value\n        const keys = Object.keys(props)\n        const nextKeys = Object.keys(nextProps)\n        return (\n          nextKeys.length !== keys.length ||\n          nextKeys.some(key => props[key] !== nextProps[key])\n        )\n      }\n\n      // add a custom deriveStoresFromProps lifecyle method\n      static getDerivedStateFromProps (props, state) {\n        if (super.deriveStoresFromProps) {\n          // inject all local stores and let the user mutate them directly\n          const stores = mapStateToStores(state)\n          super.deriveStoresFromProps(props, ...stores)\n        }\n        // respect user defined getDerivedStateFromProps\n        if (super.getDerivedStateFromProps) {\n          return super.getDerivedStateFromProps(props, state)\n        }\n        return null\n      }\n\n      componentWillUnmount () {\n        // call user defined componentWillUnmount\n        if (super.componentWillUnmount) {\n          super.componentWillUnmount()\n        }\n        // clean up memory used by Easy State\n        unobserve(this.render)\n      }\n    }\n\n    ReactiveComp = ReactiveClassComp\n  }\n\n  ReactiveComp.displayName = Comp.displayName || Comp.name\n  // static props are inherited by class components,\n  // but have to be copied for function components\n  if (isStatelessComp) {\n    for (let key of Object.keys(Comp)) {\n      ReactiveComp[key] = Comp[key]\n    }\n  }\n\n  return ReactiveComp\n}\n\nfunction mapStateToStores (state) {\n  // find store properties and map them to their none observable raw value\n  // to do not trigger none static this.setState calls\n  // from the static getDerivedStateFromProps lifecycle method\n  const component = state[COMPONENT]\n  return Object.keys(component)\n    .map(key => component[key])\n    .filter(isObservable)\n    .map(raw)\n}\n","import { useMemo } from 'react'\nimport { observable } from '@nx-js/observer-util'\nimport { isInsideFunctionComponent } from './view'\nimport { hasHooks } from './utils'\n\nexport default function store (obj) {\n  // do not create new versions of the store on every render\n  // if it is a local store in a function component\n  // create a memoized store at the first call instead\n  if (hasHooks && isInsideFunctionComponent) {\n    return useMemo(() => observable(obj), [])\n  }\n  return observable(obj)\n}\n","/* eslint camelcase: 0 */\n\n// react platform is set to either react-dom or react-native during test and execution\nimport { unstable_batchedUpdates } from 'react-platform'\nimport { globalObj } from './utils'\n\n// this runs the passed function and delays all re-renders\n// until the function is finished running\nexport function batch (fn, ctx, args) {\n  let result\n  unstable_batchedUpdates(() => (result = fn.apply(ctx, args)))\n  return result\n}\n\n// this creates and returns a batched version of the passed function\n// the cache is necessary to always map the same thing to the same function\n// which makes sure that addEventListener/removeEventListener pairs don't break\nconst cache = new WeakMap()\nfunction batchFn (fn) {\n  if (typeof fn !== 'function') {\n    return fn\n  }\n  let batched = cache.get(fn)\n  if (!batched) {\n    batched = function (...args) {\n      return batch(fn, this, args)\n    }\n    cache.set(fn, batched)\n  }\n  return batched\n}\n\n// batched obj.addEventListener(cb) like callbacks\nfunction batchMethodsCallbacks (obj, methods) {\n  methods.forEach(method => batchMethodCallbacks(obj, method))\n}\n\nfunction batchMethodCallbacks (obj, method) {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, method)\n  if (\n    descriptor &&\n    descriptor.writable &&\n    typeof descriptor.value === 'function'\n  ) {\n    obj[method] = new Proxy(descriptor.value, {\n      apply (target, ctx, args) {\n        return Reflect.apply(target, ctx, args.map(batchFn))\n      }\n    })\n  }\n}\n\n// batches obj.onevent = fn like calls\nfunction batchMethods (obj, methods) {\n  methods.forEach(method => batchMethod(obj, method))\n}\n\nfunction batchMethod (obj, method) {\n  const descriptor = Object.getOwnPropertyDescriptor(obj, method)\n  if (descriptor && descriptor.configurable) {\n    const newDescriptor = Object.assign({}, descriptor, {\n      set (value) {\n        return descriptor.set.call(this, batchFn(value))\n      }\n    })\n    Object.defineProperty(obj, method, newDescriptor)\n  }\n}\n\n// do a sync batching for the most common task sources\n// this should be removed when React's own batching is improved in the future\n\n// batch timer functions\nbatchMethodsCallbacks(globalObj, [\n  'setTimeout',\n  'setInterval',\n  'requestAnimationFrame',\n  'requestIdleCallback'\n])\n\nif (globalObj.Promise) {\n  batchMethodsCallbacks(Promise.prototype, ['then', 'catch'])\n}\n\n// batch addEventListener calls\nif (globalObj.EventTarget) {\n  batchMethodsCallbacks(EventTarget.prototype, [\n    'addEventListener',\n    'removeEventListener'\n  ])\n}\n\n// this batches websocket event handlers\nif (globalObj.WebSocket) {\n  batchMethods(WebSocket.prototype, [\n    'onopen',\n    'onmessage',\n    'onerror',\n    'onclose'\n  ])\n}\n\n// HTTP event handlers are usually wrapped by Promises, which is covered above\n"]},"metadata":{},"sourceType":"module"}