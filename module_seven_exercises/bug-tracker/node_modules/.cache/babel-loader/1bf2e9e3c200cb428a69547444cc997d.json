{"ast":null,"code":"var connectionStore = new WeakMap();\nvar ITERATION_KEY = Symbol('iteration key');\n\nfunction storeObservable(obj) {\n  // this will be used to save (obj.key -> reaction) connections later\n  connectionStore.set(obj, new Map());\n}\n\nfunction registerReactionForOperation(reaction, ref) {\n  var target = ref.target;\n  var key = ref.key;\n  var type = ref.type;\n\n  if (type === 'iterate') {\n    key = ITERATION_KEY;\n  }\n\n  var reactionsForObj = connectionStore.get(target);\n  var reactionsForKey = reactionsForObj.get(key);\n\n  if (!reactionsForKey) {\n    reactionsForKey = new Set();\n    reactionsForObj.set(key, reactionsForKey);\n  } // save the fact that the key is used by the reaction during its current run\n\n\n  if (!reactionsForKey.has(reaction)) {\n    reactionsForKey.add(reaction);\n    reaction.cleaners.push(reactionsForKey);\n  }\n}\n\nfunction getReactionsForOperation(ref) {\n  var target = ref.target;\n  var key = ref.key;\n  var type = ref.type;\n  var reactionsForTarget = connectionStore.get(target);\n  var reactionsForKey = new Set();\n\n  if (type === 'clear') {\n    reactionsForTarget.forEach(function (_, key) {\n      addReactionsForKey(reactionsForKey, reactionsForTarget, key);\n    });\n  } else {\n    addReactionsForKey(reactionsForKey, reactionsForTarget, key);\n  }\n\n  if (type === 'add' || type === 'delete' || type === 'clear') {\n    var iterationKey = Array.isArray(target) ? 'length' : ITERATION_KEY;\n    addReactionsForKey(reactionsForKey, reactionsForTarget, iterationKey);\n  }\n\n  return reactionsForKey;\n}\n\nfunction addReactionsForKey(reactionsForKey, reactionsForTarget, key) {\n  var reactions = reactionsForTarget.get(key);\n  reactions && reactions.forEach(reactionsForKey.add, reactionsForKey);\n}\n\nfunction releaseReaction(reaction) {\n  if (reaction.cleaners) {\n    reaction.cleaners.forEach(releaseReactionKeyConnection, reaction);\n  }\n\n  reaction.cleaners = [];\n}\n\nfunction releaseReactionKeyConnection(reactionsForKey) {\n  reactionsForKey.delete(this);\n} // reactions can call each other and form a call stack\n\n\nvar reactionStack = [];\nvar isDebugging = false;\n\nfunction runAsReaction(reaction, fn, context, args) {\n  // do not build reactive relations, if the reaction is unobserved\n  if (reaction.unobserved) {\n    return Reflect.apply(fn, context, args);\n  } // only run the reaction if it is not already in the reaction stack\n  // TODO: improve this to allow explicitly recursive reactions\n\n\n  if (reactionStack.indexOf(reaction) === -1) {\n    // release the (obj -> key -> reactions) connections\n    // and reset the cleaner connections\n    releaseReaction(reaction);\n\n    try {\n      // set the reaction as the currently running one\n      // this is required so that we can create (observable.prop -> reaction) pairs in the get trap\n      reactionStack.push(reaction);\n      return Reflect.apply(fn, context, args);\n    } finally {\n      // always remove the currently running flag from the reaction when it stops execution\n      reactionStack.pop();\n    }\n  }\n} // register the currently running reaction to be queued again on obj.key mutations\n\n\nfunction registerRunningReactionForOperation(operation) {\n  // get the current reaction from the top of the stack\n  var runningReaction = reactionStack[reactionStack.length - 1];\n\n  if (runningReaction) {\n    debugOperation(runningReaction, operation);\n    registerReactionForOperation(runningReaction, operation);\n  }\n}\n\nfunction queueReactionsForOperation(operation) {\n  // iterate and queue every reaction, which is triggered by obj.key mutation\n  getReactionsForOperation(operation).forEach(queueReaction, operation);\n}\n\nfunction queueReaction(reaction) {\n  debugOperation(reaction, this); // queue the reaction for later execution or run it immediately\n\n  if (typeof reaction.scheduler === 'function') {\n    reaction.scheduler(reaction);\n  } else if (typeof reaction.scheduler === 'object') {\n    reaction.scheduler.add(reaction);\n  } else {\n    reaction();\n  }\n}\n\nfunction debugOperation(reaction, operation) {\n  if (reaction.debugger && !isDebugging) {\n    try {\n      isDebugging = true;\n      reaction.debugger(operation);\n    } finally {\n      isDebugging = false;\n    }\n  }\n}\n\nfunction hasRunningReaction() {\n  return reactionStack.length > 0;\n}\n\nvar IS_REACTION = Symbol('is reaction');\n\nfunction observe(fn, options) {\n  if (options === void 0) options = {}; // wrap the passed function in a reaction, if it is not already one\n\n  var reaction = fn[IS_REACTION] ? fn : function reaction() {\n    return runAsReaction(reaction, fn, this, arguments);\n  }; // save the scheduler and debugger on the reaction\n\n  reaction.scheduler = options.scheduler;\n  reaction.debugger = options.debugger; // save the fact that this is a reaction\n\n  reaction[IS_REACTION] = true; // run the reaction once if it is not a lazy one\n\n  if (!options.lazy) {\n    reaction();\n  }\n\n  return reaction;\n}\n\nfunction unobserve(reaction) {\n  // do nothing, if the reaction is already unobserved\n  if (!reaction.unobserved) {\n    // indicate that the reaction should not be triggered any more\n    reaction.unobserved = true; // release (obj -> key -> reaction) connections\n\n    releaseReaction(reaction);\n  } // unschedule the reaction, if it is scheduled\n\n\n  if (typeof reaction.scheduler === 'object') {\n    reaction.scheduler.delete(reaction);\n  }\n}\n\nvar proxyToRaw = new WeakMap();\nvar rawToProxy = new WeakMap();\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction findObservable(obj) {\n  var observableObj = rawToProxy.get(obj);\n\n  if (hasRunningReaction() && typeof obj === 'object' && obj !== null) {\n    if (observableObj) {\n      return observableObj;\n    }\n\n    return observable(obj);\n  }\n\n  return observableObj || obj;\n}\n\nfunction patchIterator(iterator, isEntries) {\n  var originalNext = iterator.next;\n\n  iterator.next = function () {\n    var ref = originalNext.call(iterator);\n    var done = ref.done;\n    var value = ref.value;\n\n    if (!done) {\n      if (isEntries) {\n        value[1] = findObservable(value[1]);\n      } else {\n        value = findObservable(value);\n      }\n    }\n\n    return {\n      done: done,\n      value: value\n    };\n  };\n\n  return iterator;\n}\n\nvar instrumentations = {\n  has: function has(key) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({\n      target: target,\n      key: key,\n      type: 'has'\n    });\n    return proto.has.apply(target, arguments);\n  },\n  get: function get(key) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({\n      target: target,\n      key: key,\n      type: 'get'\n    });\n    return findObservable(proto.get.apply(target, arguments));\n  },\n  add: function add(key) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    var hadKey = proto.has.call(target, key); // forward the operation before queueing reactions\n\n    var result = proto.add.apply(target, arguments);\n\n    if (!hadKey) {\n      queueReactionsForOperation({\n        target: target,\n        key: key,\n        value: key,\n        type: 'add'\n      });\n    }\n\n    return result;\n  },\n  set: function set(key, value) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    var hadKey = proto.has.call(target, key);\n    var oldValue = proto.get.call(target, key); // forward the operation before queueing reactions\n\n    var result = proto.set.apply(target, arguments);\n\n    if (!hadKey) {\n      queueReactionsForOperation({\n        target: target,\n        key: key,\n        value: value,\n        type: 'add'\n      });\n    } else if (value !== oldValue) {\n      queueReactionsForOperation({\n        target: target,\n        key: key,\n        value: value,\n        oldValue: oldValue,\n        type: 'set'\n      });\n    }\n\n    return result;\n  },\n  delete: function delete$1(key) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    var hadKey = proto.has.call(target, key);\n    var oldValue = proto.get ? proto.get.call(target, key) : undefined; // forward the operation before queueing reactions\n\n    var result = proto.delete.apply(target, arguments);\n\n    if (hadKey) {\n      queueReactionsForOperation({\n        target: target,\n        key: key,\n        oldValue: oldValue,\n        type: 'delete'\n      });\n    }\n\n    return result;\n  },\n  clear: function clear() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    var hadItems = target.size !== 0;\n    var oldTarget = target instanceof Map ? new Map(target) : new Set(target); // forward the operation before queueing reactions\n\n    var result = proto.clear.apply(target, arguments);\n\n    if (hadItems) {\n      queueReactionsForOperation({\n        target: target,\n        oldTarget: oldTarget,\n        type: 'clear'\n      });\n    }\n\n    return result;\n  },\n  forEach: function forEach(cb) {\n    var args = [],\n        len = arguments.length - 1;\n\n    while (len-- > 0) args[len] = arguments[len + 1];\n\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({\n      target: target,\n      type: 'iterate'\n    }); // swap out the raw values with their observable pairs\n    // before passing them to the callback\n\n    var wrappedCb = function (value) {\n      var rest = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) rest[len] = arguments[len + 1];\n\n      return cb.apply(void 0, [findObservable(value)].concat(rest));\n    };\n\n    return (ref = proto.forEach).call.apply(ref, [target, wrappedCb].concat(args));\n    var ref;\n  },\n  keys: function keys() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({\n      target: target,\n      type: 'iterate'\n    });\n    return proto.keys.apply(target, arguments);\n  },\n  values: function values() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({\n      target: target,\n      type: 'iterate'\n    });\n    var iterator = proto.values.apply(target, arguments);\n    return patchIterator(iterator, false);\n  },\n  entries: function entries() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({\n      target: target,\n      type: 'iterate'\n    });\n    var iterator = proto.entries.apply(target, arguments);\n    return patchIterator(iterator, true);\n  },\n\n  get size() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({\n      target: target,\n      type: 'iterate'\n    });\n    return Reflect.get(proto, 'size', target);\n  }\n\n};\n\ninstrumentations[Symbol.iterator] = function () {\n  var target = proxyToRaw.get(this);\n  var proto = Reflect.getPrototypeOf(this);\n  registerRunningReactionForOperation({\n    target: target,\n    type: 'iterate'\n  });\n  var iterator = proto[Symbol.iterator].apply(target, arguments);\n  return patchIterator(iterator, target instanceof Map);\n};\n\nvar collectionHandlers = {\n  get: function get(target, key, receiver) {\n    // instrument methods and property accessors to be reactive\n    target = hasOwnProperty.call(instrumentations, key) ? instrumentations : target;\n    return Reflect.get(target, key, receiver);\n  }\n}; // eslint-disable-next-line\n\nvar globalObj = typeof window === 'object' ? window : Function('return this')(); // built-in object can not be wrapped by Proxies\n// their methods expect the object instance as the 'this' instead of the Proxy wrapper\n// complex objects are wrapped with a Proxy of instrumented methods\n// which switch the proxy to the raw object and to add reactive wiring\n\nvar handlers = new Map([[Map, collectionHandlers], [Set, collectionHandlers], [WeakMap, collectionHandlers], [WeakSet, collectionHandlers], [Object, false], [Array, false], [Int8Array, false], [Uint8Array, false], [Uint8ClampedArray, false], [Int16Array, false], [Uint16Array, false], [Int32Array, false], [Uint32Array, false], [Float32Array, false], [Float64Array, false]]);\n\nfunction shouldInstrument(ref) {\n  var constructor = ref.constructor;\n  var isBuiltIn = typeof constructor === 'function' && constructor.name in globalObj && globalObj[constructor.name] === constructor;\n  return !isBuiltIn || handlers.has(constructor);\n}\n\nfunction getHandlers(obj) {\n  return handlers.get(obj.constructor);\n}\n\nvar hasOwnProperty$1 = Object.prototype.hasOwnProperty;\nvar wellKnownSymbols = new Set(Object.getOwnPropertyNames(Symbol).map(function (key) {\n  return Symbol[key];\n}).filter(function (value) {\n  return typeof value === 'symbol';\n})); // intercept get operations on observables to know which reaction uses their properties\n\nfunction get(target, key, receiver) {\n  var result = Reflect.get(target, key, receiver); // do not register (observable.prop -> reaction) pairs for well known symbols\n  // these symbols are frequently retrieved in low level JavaScript under the hood\n\n  if (typeof key === 'symbol' && wellKnownSymbols.has(key)) {\n    return result;\n  } // register and save (observable.prop -> runningReaction)\n\n\n  registerRunningReactionForOperation({\n    target: target,\n    key: key,\n    receiver: receiver,\n    type: 'get'\n  }); // if we are inside a reaction and observable.prop is an object wrap it in an observable too\n  // this is needed to intercept property access on that object too (dynamic observable tree)\n\n  var observableResult = rawToProxy.get(result);\n\n  if (hasRunningReaction() && typeof result === 'object' && result !== null) {\n    if (observableResult) {\n      return observableResult;\n    } // do not violate the none-configurable none-writable prop get handler invariant\n    // fall back to none reactive mode in this case, instead of letting the Proxy throw a TypeError\n\n\n    var descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n\n    if (!descriptor || !(descriptor.writable === false && descriptor.configurable === false)) {\n      return observable(result);\n    }\n  } // otherwise return the observable wrapper if it is already created and cached or the raw object\n\n\n  return observableResult || result;\n}\n\nfunction has(target, key) {\n  var result = Reflect.has(target, key); // register and save (observable.prop -> runningReaction)\n\n  registerRunningReactionForOperation({\n    target: target,\n    key: key,\n    type: 'has'\n  });\n  return result;\n}\n\nfunction ownKeys(target) {\n  registerRunningReactionForOperation({\n    target: target,\n    type: 'iterate'\n  });\n  return Reflect.ownKeys(target);\n} // intercept set operations on observables to know when to trigger reactions\n\n\nfunction set(target, key, value, receiver) {\n  // make sure to do not pollute the raw object with observables\n  if (typeof value === 'object' && value !== null) {\n    value = proxyToRaw.get(value) || value;\n  } // save if the object had a descriptor for this key\n\n\n  var hadKey = hasOwnProperty$1.call(target, key); // save if the value changed because of this set operation\n\n  var oldValue = target[key]; // execute the set operation before running any reaction\n\n  var result = Reflect.set(target, key, value, receiver); // do not queue reactions if the target of the operation is not the raw receiver\n  // (possible because of prototypal inheritance)\n\n  if (target !== proxyToRaw.get(receiver)) {\n    return result;\n  } // queue a reaction if it's a new property or its value changed\n\n\n  if (!hadKey) {\n    queueReactionsForOperation({\n      target: target,\n      key: key,\n      value: value,\n      receiver: receiver,\n      type: 'add'\n    });\n  } else if (value !== oldValue) {\n    queueReactionsForOperation({\n      target: target,\n      key: key,\n      value: value,\n      oldValue: oldValue,\n      receiver: receiver,\n      type: 'set'\n    });\n  }\n\n  return result;\n}\n\nfunction deleteProperty(target, key) {\n  // save if the object had the key\n  var hadKey = hasOwnProperty$1.call(target, key);\n  var oldValue = target[key]; // execute the delete operation before running any reaction\n\n  var result = Reflect.deleteProperty(target, key); // only queue reactions for delete operations which resulted in an actual change\n\n  if (hadKey) {\n    queueReactionsForOperation({\n      target: target,\n      key: key,\n      oldValue: oldValue,\n      type: 'delete'\n    });\n  }\n\n  return result;\n}\n\nvar baseHandlers = {\n  get: get,\n  has: has,\n  ownKeys: ownKeys,\n  set: set,\n  deleteProperty: deleteProperty\n};\n\nfunction observable(obj) {\n  if (obj === void 0) obj = {}; // if it is already an observable or it should not be wrapped, return it\n\n  if (proxyToRaw.has(obj) || !shouldInstrument(obj)) {\n    return obj;\n  } // if it already has a cached observable wrapper, return it\n  // otherwise create a new observable\n\n\n  return rawToProxy.get(obj) || createObservable(obj);\n}\n\nfunction createObservable(obj) {\n  // if it is a complex built-in object or a normal object, wrap it\n  var handlers = getHandlers(obj) || baseHandlers;\n  var observable = new Proxy(obj, handlers); // save these to switch between the raw object and the wrapped object with ease later\n\n  rawToProxy.set(obj, observable);\n  proxyToRaw.set(observable, obj); // init basic data structures to save and cleanup later (observable.prop -> reaction) connections\n\n  storeObservable(obj);\n  return observable;\n}\n\nfunction isObservable(obj) {\n  return proxyToRaw.has(obj);\n}\n\nfunction raw(obj) {\n  return proxyToRaw.get(obj) || obj;\n}\n\nexport { observe, unobserve, observable, isObservable, raw };","map":{"version":3,"sources":["C:/Users/shoem/Documents/mthree/module_seven_exercises/bug-tracker/node_modules/@nx-js/observer-util/dist/es.es5.js"],"names":["connectionStore","WeakMap","ITERATION_KEY","Symbol","storeObservable","obj","set","Map","registerReactionForOperation","reaction","ref","target","key","type","reactionsForObj","get","reactionsForKey","Set","has","add","cleaners","push","getReactionsForOperation","reactionsForTarget","forEach","_","addReactionsForKey","iterationKey","Array","isArray","reactions","releaseReaction","releaseReactionKeyConnection","delete","reactionStack","isDebugging","runAsReaction","fn","context","args","unobserved","Reflect","apply","indexOf","pop","registerRunningReactionForOperation","operation","runningReaction","length","debugOperation","queueReactionsForOperation","queueReaction","scheduler","debugger","hasRunningReaction","IS_REACTION","observe","options","arguments","lazy","unobserve","proxyToRaw","rawToProxy","hasOwnProperty","Object","prototype","findObservable","observableObj","observable","patchIterator","iterator","isEntries","originalNext","next","call","done","value","instrumentations","proto","getPrototypeOf","hadKey","result","oldValue","delete$1","undefined","clear","hadItems","size","oldTarget","cb","len","wrappedCb","rest","concat","keys","values","entries","collectionHandlers","receiver","globalObj","window","Function","handlers","WeakSet","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","shouldInstrument","constructor","isBuiltIn","name","getHandlers","hasOwnProperty$1","wellKnownSymbols","getOwnPropertyNames","map","filter","observableResult","descriptor","getOwnPropertyDescriptor","writable","configurable","ownKeys","deleteProperty","baseHandlers","createObservable","Proxy","isObservable","raw"],"mappings":"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","sourcesContent":["var connectionStore = new WeakMap();\nvar ITERATION_KEY = Symbol('iteration key');\n\nfunction storeObservable(obj) {\n  // this will be used to save (obj.key -> reaction) connections later\n  connectionStore.set(obj, new Map());\n}\n\nfunction registerReactionForOperation(reaction, ref) {\n  var target = ref.target;\n  var key = ref.key;\n  var type = ref.type;\n\n  if (type === 'iterate') {\n    key = ITERATION_KEY;\n  }\n\n  var reactionsForObj = connectionStore.get(target);\n  var reactionsForKey = reactionsForObj.get(key);\n  if (!reactionsForKey) {\n    reactionsForKey = new Set();\n    reactionsForObj.set(key, reactionsForKey);\n  }\n  // save the fact that the key is used by the reaction during its current run\n  if (!reactionsForKey.has(reaction)) {\n    reactionsForKey.add(reaction);\n    reaction.cleaners.push(reactionsForKey);\n  }\n}\n\nfunction getReactionsForOperation(ref) {\n  var target = ref.target;\n  var key = ref.key;\n  var type = ref.type;\n\n  var reactionsForTarget = connectionStore.get(target);\n  var reactionsForKey = new Set();\n\n  if (type === 'clear') {\n    reactionsForTarget.forEach(function (_, key) {\n      addReactionsForKey(reactionsForKey, reactionsForTarget, key);\n    });\n  } else {\n    addReactionsForKey(reactionsForKey, reactionsForTarget, key);\n  }\n\n  if (type === 'add' || type === 'delete' || type === 'clear') {\n    var iterationKey = Array.isArray(target) ? 'length' : ITERATION_KEY;\n    addReactionsForKey(reactionsForKey, reactionsForTarget, iterationKey);\n  }\n\n  return reactionsForKey;\n}\n\nfunction addReactionsForKey(reactionsForKey, reactionsForTarget, key) {\n  var reactions = reactionsForTarget.get(key);\n  reactions && reactions.forEach(reactionsForKey.add, reactionsForKey);\n}\n\nfunction releaseReaction(reaction) {\n  if (reaction.cleaners) {\n    reaction.cleaners.forEach(releaseReactionKeyConnection, reaction);\n  }\n  reaction.cleaners = [];\n}\n\nfunction releaseReactionKeyConnection(reactionsForKey) {\n  reactionsForKey.delete(this);\n}\n\n// reactions can call each other and form a call stack\nvar reactionStack = [];\nvar isDebugging = false;\n\nfunction runAsReaction(reaction, fn, context, args) {\n  // do not build reactive relations, if the reaction is unobserved\n  if (reaction.unobserved) {\n    return Reflect.apply(fn, context, args);\n  }\n\n  // only run the reaction if it is not already in the reaction stack\n  // TODO: improve this to allow explicitly recursive reactions\n  if (reactionStack.indexOf(reaction) === -1) {\n    // release the (obj -> key -> reactions) connections\n    // and reset the cleaner connections\n    releaseReaction(reaction);\n\n    try {\n      // set the reaction as the currently running one\n      // this is required so that we can create (observable.prop -> reaction) pairs in the get trap\n      reactionStack.push(reaction);\n      return Reflect.apply(fn, context, args);\n    } finally {\n      // always remove the currently running flag from the reaction when it stops execution\n      reactionStack.pop();\n    }\n  }\n}\n\n// register the currently running reaction to be queued again on obj.key mutations\nfunction registerRunningReactionForOperation(operation) {\n  // get the current reaction from the top of the stack\n  var runningReaction = reactionStack[reactionStack.length - 1];\n  if (runningReaction) {\n    debugOperation(runningReaction, operation);\n    registerReactionForOperation(runningReaction, operation);\n  }\n}\n\nfunction queueReactionsForOperation(operation) {\n  // iterate and queue every reaction, which is triggered by obj.key mutation\n  getReactionsForOperation(operation).forEach(queueReaction, operation);\n}\n\nfunction queueReaction(reaction) {\n  debugOperation(reaction, this);\n  // queue the reaction for later execution or run it immediately\n  if (typeof reaction.scheduler === 'function') {\n    reaction.scheduler(reaction);\n  } else if (typeof reaction.scheduler === 'object') {\n    reaction.scheduler.add(reaction);\n  } else {\n    reaction();\n  }\n}\n\nfunction debugOperation(reaction, operation) {\n  if (reaction.debugger && !isDebugging) {\n    try {\n      isDebugging = true;\n      reaction.debugger(operation);\n    } finally {\n      isDebugging = false;\n    }\n  }\n}\n\nfunction hasRunningReaction() {\n  return reactionStack.length > 0;\n}\n\nvar IS_REACTION = Symbol('is reaction');\n\nfunction observe(fn, options) {\n  if ( options === void 0 ) options = {};\n\n  // wrap the passed function in a reaction, if it is not already one\n  var reaction = fn[IS_REACTION] ? fn : function reaction() {\n    return runAsReaction(reaction, fn, this, arguments);\n  };\n  // save the scheduler and debugger on the reaction\n  reaction.scheduler = options.scheduler;\n  reaction.debugger = options.debugger;\n  // save the fact that this is a reaction\n  reaction[IS_REACTION] = true;\n  // run the reaction once if it is not a lazy one\n  if (!options.lazy) {\n    reaction();\n  }\n  return reaction;\n}\n\nfunction unobserve(reaction) {\n  // do nothing, if the reaction is already unobserved\n  if (!reaction.unobserved) {\n    // indicate that the reaction should not be triggered any more\n    reaction.unobserved = true;\n    // release (obj -> key -> reaction) connections\n    releaseReaction(reaction);\n  }\n  // unschedule the reaction, if it is scheduled\n  if (typeof reaction.scheduler === 'object') {\n    reaction.scheduler.delete(reaction);\n  }\n}\n\nvar proxyToRaw = new WeakMap();\nvar rawToProxy = new WeakMap();\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction findObservable(obj) {\n  var observableObj = rawToProxy.get(obj);\n  if (hasRunningReaction() && typeof obj === 'object' && obj !== null) {\n    if (observableObj) {\n      return observableObj;\n    }\n    return observable(obj);\n  }\n  return observableObj || obj;\n}\n\nfunction patchIterator(iterator, isEntries) {\n  var originalNext = iterator.next;\n  iterator.next = function () {\n    var ref = originalNext.call(iterator);\n    var done = ref.done;\n    var value = ref.value;\n    if (!done) {\n      if (isEntries) {\n        value[1] = findObservable(value[1]);\n      } else {\n        value = findObservable(value);\n      }\n    }\n    return { done: done, value: value };\n  };\n  return iterator;\n}\n\nvar instrumentations = {\n  has: function has(key) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, key: key, type: 'has' });\n    return proto.has.apply(target, arguments);\n  },\n  get: function get(key) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, key: key, type: 'get' });\n    return findObservable(proto.get.apply(target, arguments));\n  },\n  add: function add(key) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    var hadKey = proto.has.call(target, key);\n    // forward the operation before queueing reactions\n    var result = proto.add.apply(target, arguments);\n    if (!hadKey) {\n      queueReactionsForOperation({ target: target, key: key, value: key, type: 'add' });\n    }\n    return result;\n  },\n  set: function set(key, value) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    var hadKey = proto.has.call(target, key);\n    var oldValue = proto.get.call(target, key);\n    // forward the operation before queueing reactions\n    var result = proto.set.apply(target, arguments);\n    if (!hadKey) {\n      queueReactionsForOperation({ target: target, key: key, value: value, type: 'add' });\n    } else if (value !== oldValue) {\n      queueReactionsForOperation({ target: target, key: key, value: value, oldValue: oldValue, type: 'set' });\n    }\n    return result;\n  },\n  delete: function delete$1(key) {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    var hadKey = proto.has.call(target, key);\n    var oldValue = proto.get ? proto.get.call(target, key) : undefined;\n    // forward the operation before queueing reactions\n    var result = proto.delete.apply(target, arguments);\n    if (hadKey) {\n      queueReactionsForOperation({ target: target, key: key, oldValue: oldValue, type: 'delete' });\n    }\n    return result;\n  },\n  clear: function clear() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    var hadItems = target.size !== 0;\n    var oldTarget = target instanceof Map ? new Map(target) : new Set(target);\n    // forward the operation before queueing reactions\n    var result = proto.clear.apply(target, arguments);\n    if (hadItems) {\n      queueReactionsForOperation({ target: target, oldTarget: oldTarget, type: 'clear' });\n    }\n    return result;\n  },\n  forEach: function forEach(cb) {\n    var args = [], len = arguments.length - 1;\n    while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    // swap out the raw values with their observable pairs\n    // before passing them to the callback\n    var wrappedCb = function (value) {\n      var rest = [], len = arguments.length - 1;\n      while ( len-- > 0 ) rest[ len ] = arguments[ len + 1 ];\n\n      return cb.apply(void 0, [ findObservable(value) ].concat( rest ));\n    };\n    return (ref = proto.forEach).call.apply(ref, [ target, wrappedCb ].concat( args ));\n    var ref;\n  },\n  keys: function keys() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    return proto.keys.apply(target, arguments);\n  },\n  values: function values() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    var iterator = proto.values.apply(target, arguments);\n    return patchIterator(iterator, false);\n  },\n  entries: function entries() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    var iterator = proto.entries.apply(target, arguments);\n    return patchIterator(iterator, true);\n  },\n  get size() {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    return Reflect.get(proto, 'size', target);\n  }\n};\ninstrumentations[Symbol.iterator] = function () {\n    var target = proxyToRaw.get(this);\n    var proto = Reflect.getPrototypeOf(this);\n    registerRunningReactionForOperation({ target: target, type: 'iterate' });\n    var iterator = proto[Symbol.iterator].apply(target, arguments);\n    return patchIterator(iterator, target instanceof Map);\n  };\n\nvar collectionHandlers = {\n  get: function get(target, key, receiver) {\n    // instrument methods and property accessors to be reactive\n    target = hasOwnProperty.call(instrumentations, key) ? instrumentations : target;\n    return Reflect.get(target, key, receiver);\n  }\n};\n\n// eslint-disable-next-line\nvar globalObj = typeof window === 'object' ? window : Function('return this')();\n\n// built-in object can not be wrapped by Proxies\n// their methods expect the object instance as the 'this' instead of the Proxy wrapper\n// complex objects are wrapped with a Proxy of instrumented methods\n// which switch the proxy to the raw object and to add reactive wiring\nvar handlers = new Map([[Map, collectionHandlers], [Set, collectionHandlers], [WeakMap, collectionHandlers], [WeakSet, collectionHandlers], [Object, false], [Array, false], [Int8Array, false], [Uint8Array, false], [Uint8ClampedArray, false], [Int16Array, false], [Uint16Array, false], [Int32Array, false], [Uint32Array, false], [Float32Array, false], [Float64Array, false]]);\n\nfunction shouldInstrument(ref) {\n  var constructor = ref.constructor;\n\n  var isBuiltIn = typeof constructor === 'function' && constructor.name in globalObj && globalObj[constructor.name] === constructor;\n  return !isBuiltIn || handlers.has(constructor);\n}\n\nfunction getHandlers(obj) {\n  return handlers.get(obj.constructor);\n}\n\nvar hasOwnProperty$1 = Object.prototype.hasOwnProperty;\nvar wellKnownSymbols = new Set(Object.getOwnPropertyNames(Symbol).map(function (key) { return Symbol[key]; }).filter(function (value) { return typeof value === 'symbol'; }));\n\n// intercept get operations on observables to know which reaction uses their properties\nfunction get(target, key, receiver) {\n  var result = Reflect.get(target, key, receiver);\n  // do not register (observable.prop -> reaction) pairs for well known symbols\n  // these symbols are frequently retrieved in low level JavaScript under the hood\n  if (typeof key === 'symbol' && wellKnownSymbols.has(key)) {\n    return result;\n  }\n  // register and save (observable.prop -> runningReaction)\n  registerRunningReactionForOperation({ target: target, key: key, receiver: receiver, type: 'get' });\n  // if we are inside a reaction and observable.prop is an object wrap it in an observable too\n  // this is needed to intercept property access on that object too (dynamic observable tree)\n  var observableResult = rawToProxy.get(result);\n  if (hasRunningReaction() && typeof result === 'object' && result !== null) {\n    if (observableResult) {\n      return observableResult;\n    }\n    // do not violate the none-configurable none-writable prop get handler invariant\n    // fall back to none reactive mode in this case, instead of letting the Proxy throw a TypeError\n    var descriptor = Reflect.getOwnPropertyDescriptor(target, key);\n    if (!descriptor || !(descriptor.writable === false && descriptor.configurable === false)) {\n      return observable(result);\n    }\n  }\n  // otherwise return the observable wrapper if it is already created and cached or the raw object\n  return observableResult || result;\n}\n\nfunction has(target, key) {\n  var result = Reflect.has(target, key);\n  // register and save (observable.prop -> runningReaction)\n  registerRunningReactionForOperation({ target: target, key: key, type: 'has' });\n  return result;\n}\n\nfunction ownKeys(target) {\n  registerRunningReactionForOperation({ target: target, type: 'iterate' });\n  return Reflect.ownKeys(target);\n}\n\n// intercept set operations on observables to know when to trigger reactions\nfunction set(target, key, value, receiver) {\n  // make sure to do not pollute the raw object with observables\n  if (typeof value === 'object' && value !== null) {\n    value = proxyToRaw.get(value) || value;\n  }\n  // save if the object had a descriptor for this key\n  var hadKey = hasOwnProperty$1.call(target, key);\n  // save if the value changed because of this set operation\n  var oldValue = target[key];\n  // execute the set operation before running any reaction\n  var result = Reflect.set(target, key, value, receiver);\n  // do not queue reactions if the target of the operation is not the raw receiver\n  // (possible because of prototypal inheritance)\n  if (target !== proxyToRaw.get(receiver)) {\n    return result;\n  }\n  // queue a reaction if it's a new property or its value changed\n  if (!hadKey) {\n    queueReactionsForOperation({ target: target, key: key, value: value, receiver: receiver, type: 'add' });\n  } else if (value !== oldValue) {\n    queueReactionsForOperation({\n      target: target,\n      key: key,\n      value: value,\n      oldValue: oldValue,\n      receiver: receiver,\n      type: 'set'\n    });\n  }\n  return result;\n}\n\nfunction deleteProperty(target, key) {\n  // save if the object had the key\n  var hadKey = hasOwnProperty$1.call(target, key);\n  var oldValue = target[key];\n  // execute the delete operation before running any reaction\n  var result = Reflect.deleteProperty(target, key);\n  // only queue reactions for delete operations which resulted in an actual change\n  if (hadKey) {\n    queueReactionsForOperation({ target: target, key: key, oldValue: oldValue, type: 'delete' });\n  }\n  return result;\n}\n\nvar baseHandlers = { get: get, has: has, ownKeys: ownKeys, set: set, deleteProperty: deleteProperty };\n\nfunction observable(obj) {\n  if ( obj === void 0 ) obj = {};\n\n  // if it is already an observable or it should not be wrapped, return it\n  if (proxyToRaw.has(obj) || !shouldInstrument(obj)) {\n    return obj;\n  }\n  // if it already has a cached observable wrapper, return it\n  // otherwise create a new observable\n  return rawToProxy.get(obj) || createObservable(obj);\n}\n\nfunction createObservable(obj) {\n  // if it is a complex built-in object or a normal object, wrap it\n  var handlers = getHandlers(obj) || baseHandlers;\n  var observable = new Proxy(obj, handlers);\n  // save these to switch between the raw object and the wrapped object with ease later\n  rawToProxy.set(obj, observable);\n  proxyToRaw.set(observable, obj);\n  // init basic data structures to save and cleanup later (observable.prop -> reaction) connections\n  storeObservable(obj);\n  return observable;\n}\n\nfunction isObservable(obj) {\n  return proxyToRaw.has(obj);\n}\n\nfunction raw(obj) {\n  return proxyToRaw.get(obj) || obj;\n}\n\nexport { observe, unobserve, observable, isObservable, raw };\n"]},"metadata":{},"sourceType":"module"}